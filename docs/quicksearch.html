<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"doc_scripts_fulltext-search-ui.js.html":{"id":"doc_scripts_fulltext-search-ui.js.html","title":"Source: doc/scripts/fulltext-search-ui.js","body":" DocStrap Classes DecodedEncodedHasher Source: doc/scripts/fulltext-search-ui.js window.SearcherDisplay = (function($) { /** * This class provides support for displaying quick search text results to users. */ function SearcherDisplay() { } SearcherDisplay.prototype.init = function() { this._displayQuickSearch(); }; /** * This method creates the quick text search entry in navigation menu and wires all required events. */ SearcherDisplay.prototype._displayQuickSearch = function() { var quickSearch = $(document.createElement(&quot;iframe&quot;)), body = $(&quot;body&quot;), self = this; quickSearch.attr(&quot;src&quot;, &quot;quicksearch.html&quot;); quickSearch.css(&quot;width&quot;, &quot;0px&quot;); quickSearch.css(&quot;height&quot;, &quot;0px&quot;); body.append(quickSearch); $(window).on(&quot;message&quot;, function(msg) { var msgData = msg.originalEvent.data; if (msgData.msgid != &quot;docstrap.quicksearch.done&quot;) { return; } var results = msgData.results || []; self._displaySearchResults(results); }); function startSearch() { var searchTerms = $('#search-input').prop(&quot;value&quot;); if (searchTerms) { quickSearch[0].contentWindow.postMessage({ &quot;searchTerms&quot;: searchTerms, &quot;msgid&quot;: &quot;docstrap.quicksearch.start&quot; }, &quot;*&quot;); } } $('#search-input').on('keyup', function(evt) { if (evt.keyCode != 13) { return; } startSearch(); return false; }); $('#search-submit').on('click', function() { startSearch(); return false; }); }; /** * This method displays the quick text search results in a modal dialog. */ SearcherDisplay.prototype._displaySearchResults = function(results) { var resultsHolder = $($(&quot;#searchResults&quot;).find(&quot;.modal-body&quot;)), fragment = document.createDocumentFragment(), resultsList = document.createElement(&quot;ul&quot;); resultsHolder.empty(); for (var idx = 0; idx &lt; results.length; idx++) { var result = results[idx], item = document.createElement(&quot;li&quot;), link = document.createElement(&quot;a&quot;); link.href = result.id; link.innerHTML = result.title; item.appendChild(link) resultsList.appendChild(item); } fragment.appendChild(resultsList); resultsHolder.append(fragment); $(&quot;#searchResults&quot;).modal({&quot;show&quot;: true}); }; return new SearcherDisplay(); })($); × Search results Close "},"Decoded.js.html":{"id":"Decoded.js.html","title":"Source: Decoded.js","body":" DocStrap Classes DecodedEncodedHasher Source: Decoded.js &quot;use strict&quot;; const Encoded = require(&quot;./Encoded&quot;); /** * @constructor * @desc Stores hashed pass-phrase as decoded Strings. * @param {String} key - The decoded key * @param {String} salt - The decoded salt * @param {Number} iter - The number of PBKDF2 iterations */ function Decoded (key, salt, iter) { this.key = key; this.salt = salt; this.iter = iter; } /** * @method * @memberof Decoded * @desc Encodes the Decoded object into an Encoded object. * @param {String} enc - Encoding scheme to be used * @returns {Encoded} The Encoded object * @see Encoded */ Decoded.prototype.encode = function (enc) { const encodedKey = new Buffer(this.key, enc); const encodedSalt = new Buffer(this.salt, enc); const iter = this.iter; return new Encoded(encodedKey, encodedSalt, iter); } /** * @method * @memberof Decoded * @desc Concatenates the stored hash data into a hash string. * @desc The hash string has the format `iter:salt:key`. * @returns {String} The hash string */ Decoded.prototype.toString = function () { return `${this.iter}:${this.salt}:${this.key}`; } /** * @method * @memberof Decoded * @returns {String} */ Decoded.prototype.getKey = function () { return this.key; } /** * @method * @memberof Decoded * @param {Buffer} key */ Decoded.prototype.setKey = function (key) { this.key = key; } /** * @method * @memberof Decoded * @returns {Buffer} */ Decoded.prototype.getSalt = function () { return this.salt; } /** * @method * @memberof Decoded * @param {Buffer} salt */ Decoded.prototype.setSalt = function (salt) { this.salt = salt; } /** * @method * @memberof Decoded * @returns {Number} */ Decoded.prototype.getIteration = function () { return this.iter; } /** * @method * @memberof Decoded * @param {Number} iter */ Decoded.prototype.setIteration = function (iter) { this.iter = iter; } module.exports = Decoded; × Search results Close "},"Encoded.js.html":{"id":"Encoded.js.html","title":"Source: Encoded.js","body":" DocStrap Classes DecodedEncodedHasher Source: Encoded.js &quot;use strict&quot;; const Decoded = require(&quot;./Decoded&quot;); /** * @constructor * @desc Stores hashed pass-phrase as Buffers. * @param {Buffer} key - The hashed key * @param {Buffer} salt - The hashed salt * @param {Number} iter - The Number of PBKDF2 iterations */ function Encoded (key, salt, iter) { this.key = key; this.salt = salt; this.iter = iter; } /** * @method * @memberof Encoded * @desc Parses a hash string into an Encoded object. * @param {String} pass - The hash string * @param {String} enc - Encoding scheme to be used * @returns {Encoded} The Encoded object */ Encoded.parse = function (pass, enc) { const arr = pass.split(&quot;:&quot;); const key = new Buffer(arr[2], enc); const salt = new Buffer(arr[1], enc); const iter = parseInt(arr[0]); return new Encoded(key, salt, iter); }; /** * @method * @memberof Encoded * @desc Decodes the Encoded object into a Decoded object. * @param {String} enc - Encoding scheme to be used * @returns {Decoded} The Decoded object * @see Decoded */ Encoded.prototype.decode = function (enc) { const decodedKey = this.getKey().toString(enc).toUpperCase(); const decodedSalt = this.getSalt().toString(enc).toUpperCase(); const iter = this.getIteration(); return new Decoded(decodedKey, decodedSalt, iter); } /** * @method * @memberof Encoded * @desc Converts the stored hash data into a hash string. * @desc The hash string has the format &lt;code&gt;iter:salt:key&lt;/code&gt;. * @param {String} enc - Encoding scheme to be used * @see Decoded#toString */ Encoded.prototype.toString = function (enc) { const decoded = this.decode(enc); return decoded.toString(); } /** * @method * @memberof Encoded * @returns {Buffer} */ Encoded.prototype.getKey = function () { return this.key; } /** * @method * @memberof Encoded * @param {Buffer} key */ Encoded.prototype.setKey = function (key) { this.key = key; } /** * @method * @memberof Encoded * @returns {Buffer} */ Encoded.prototype.getSalt = function () { return this.salt; } /** * @method * @memberof Encoded * @param {Buffer} salt */ Encoded.prototype.setSalt = function (salt) { this.salt = salt; } /** * @method * @memberof Encoded * @returns {Number} */ Encoded.prototype.getIteration = function () { return this.iter; } /** * @method * @memberof Encoded * @param {Number} iter */ Encoded.prototype.setIteration = function (iter) { this.iter = iter; } module.exports = Encoded; × Search results Close "},"Hasher.js.html":{"id":"Hasher.js.html","title":"Source: Hasher.js","body":" DocStrap Classes DecodedEncodedHasher Source: Hasher.js &quot;use strict&quot;; const crypto = require(&quot;crypto&quot;); const randomSource = require(&quot;randbytes&quot;).urandom.getInstance(); const timeSource = require(&quot;randbytes&quot;).timeRandom.getInstance(); const Encoded = require(&quot;./Encoded&quot;); const Decoded = require(&quot;./Decoded&quot;); /** * @constructor * @desc Creates and validates hashes. By default, this class uses 30,000 iterations, Hexadecimal encoding scheme, SHA-512 hashing method, and generates a 512-byte key. * @params {Number} iteration - Number of iterations to run * @params {String} encoding - The default encoding scheme to be used * @params {String} hashMethod - The default hashing method to be implemented by PBKDF2 * @params {Number} keyLength - The length of the generated hash in bytes */ function Hasher (iteration, encoding, hashMethod, keyLength) { // Type validation (dotenv gives iteration as string, so just to be careful) if (typeof iteration !== &quot;number&quot;) throw Error(&quot;Iteration must be number&quot;); this.iter = iteration; this.hashMethod = hashMethod; if (typeof keyLength !== &quot;number&quot;) throw Error(&quot;Key length must be number&quot;); this.keylen = keyLength; this.encoding = encoding; /** * @type {Number} * @name Hasher~saltByte * @desc Length of the salt in bytes */ // Generate 64-byte salt (256/8 = 64) const saltByte = 64; /** * @method * @instance * @param {Hasher~saltCallback} callback - Handles the randomly generated salt * @param {Boolean} [urand=true] - Determines whether to use &lt;code&gt;/dev/urandom&lt;/code&gt; or the time stamp as the random source */ this.generateSalt = function (callback, urand=true) { let source = randomSource; if (!urand) source = timeSource; source.getRandomBytes(saltByte, (salt) =&gt; { callback(salt); }); } /** * This callback takes the randomly generated salt and allows it to be handled appropriately. * @callback Hasher~saltCallback * @param {Buffer} salt - Randomly generated salt */ }; /** * @method * @memberof Hasher * @desc Hashes the provided pass-phrase * @param {String} pwd - Password to hash * @param {Hasher~hashCallback} callback - Handles the hashed object * @param {Boolean} [urand=true] - Determines whether to use &lt;code&gt;/dev/urandom&lt;/code&gt; or the time stamp as the random source */ Hasher.prototype.hash = function (pwd, callback, urand=true) { this.generateSalt((salt) =&gt; { crypto.pbkdf2(pwd, salt, this.iter, this.keylen, this.hashMethod, (err, key) =&gt; { if (err) console.error(err); const hashed = new Encoded(key, salt, this.iter); callback(err, hashed); }); }, urand) }; /** * This callback takes the generated hash as an {@link Encoded} object. It also handles any errors from the PBKDF2 process. * @callback Hasher~hashCallback * @param {Object} err * @param {Encoded} hashed - The hashed object * @see Encoded */ /** * @method * @memberof Hasher * @param {String} new_ - Given pass-phrase * @param {String} old - The encoded hash string to compare to * @param {Hasher-validatorCallback} callback - Handles the validation result * @param {String=} - The encoding scheme to be used (uses &lt;code&gt;hasher.encoding&lt;/code&gt; as default) * @example * // Create a hash * hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { * const old = hashed.toString(hasher.encoding); // Generate hash string with default encoding scheme * hasher.validate(&quot;password&quot;, old, (valid) =&gt; { * assert.equal(valid, true); * }); * }); */ Hasher.prototype.validate = function (new_, old, callback, enc) { const oldHash = Encoded.parse(old, enc || this.encoding); crypto.pbkdf2(new_, oldHash.getSalt(), this.iter, this.keylen, this.hashMethod, (err, key) =&gt; { if (err) console.error(err); let valid = false; if (key.length === oldHash.getKey().length &amp;&amp; key.equals(oldHash.getKey())) valid = true; callback(valid); }); }; /** * This callback handles the validation result. * @callback Hasher~validatorCallback * @param {Boolean} valid - Validation test result */ module.exports = Hasher; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes DecodedEncodedHasher Classes Classes Decoded Encoded Hasher × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes DecodedEncodedHasher Hashing with PBKDF2This package creates a hash using the PBKDF2 method. By default, it iterates on 64-bit SHA256 hash. Random salts are generated using the randbytes package. It can be downloaded on npm here. UsageHasher objectThe Hasher object is what generates hashes. The salt is randomly generated through /dev/urandom. const pbkdf = require(&quot;pbkdf2-hash&quot;) , hasher = pbkdf.create(); hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { console.log(hashed.toString(hasher.encoding)); });If you are on a non-UNIX system, you can choose to generate random salt with a time stamp instead. To do so, you simply have to pass false to the method: hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { // Do something }, false);However, this is unrecommended and should not be used unless absolutely necessary. Hashed objectThe hash() method returns a Hashed object, which can be converted to a hex string (by default) easily. The default encoding scheme is stored in Hashed.encoding property. hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { console.log(hashed.toString(hasher.encoding)); // If you want a different encoding scheme... console.log(hashed.toString(&quot;utf8&quot;)); });It can also be used to parse an already stringified hash. hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { const h1 = hashed; const h2 = hashed.parse(hashed.toString(hasher.encoding), hasher.encoding); assert.equal(JSON.stringify(h1)).equal(JSON.stringify(h2)); });Comparing hashesYou can use the validate() method to compare two pass-phrases. The first argument is the entered password, and the second argument is the hashed password to be compared to. hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { const old = hashed.toString(hasher.encoding); hasher.validate(&quot;password&quot;, old, (valid) =&gt; { return valid; }); });The validate() method uses hasher.encoding by default, but this can be overridden by supplying the optional parameter at the end. hasher.validate(..., (valid) =&gt; { // Do something }, &quot;utf8&quot;); × Search results Close "},"Decoded.html":{"id":"Decoded.html","title":"Class: Decoded","body":" DocStrap Classes DecodedEncodedHasher Class: Decoded Decoded new Decoded(key, salt, iter) Stores hashed pass-phrase as decoded Strings. Parameters: Name Type Description key String The decoded key salt String The decoded salt iter Number The number of PBKDF2 iterations Source: Decoded.js, line 12 Methods encode(enc) Encodes the Decoded object into an Encoded object. Parameters: Name Type Description enc String Encoding scheme to be used Source: Decoded.js, line 26 See: Encoded Returns: The Encoded object Type Encoded getIteration() Source: Decoded.js, line 85 Returns: Type Number getKey() Source: Decoded.js, line 49 Returns: Type String getSalt() Source: Decoded.js, line 67 Returns: Type Buffer setIteration(iter) Parameters: Name Type Description iter Number Source: Decoded.js, line 94 setKey(key) Parameters: Name Type Description key Buffer Source: Decoded.js, line 58 setSalt(salt) Parameters: Name Type Description salt Buffer Source: Decoded.js, line 76 toString() The hash string has the format iter:salt:key. Source: Decoded.js, line 40 Returns: The hash string Type String × Search results Close "},"Encoded.html":{"id":"Encoded.html","title":"Class: Encoded","body":" DocStrap Classes DecodedEncodedHasher Class: Encoded Encoded new Encoded(key, salt, iter) Stores hashed pass-phrase as Buffers. Parameters: Name Type Description key Buffer The hashed key salt Buffer The hashed salt iter Number The Number of PBKDF2 iterations Source: Encoded.js, line 13 Methods &lt;static&gt; parse(pass, enc) Parses a hash string into an Encoded object. Parameters: Name Type Description pass String The hash string enc String Encoding scheme to be used Source: Encoded.js, line 27 Returns: The Encoded object Type Encoded decode(enc) Decodes the Encoded object into a Decoded object. Parameters: Name Type Description enc String Encoding scheme to be used Source: Encoded.js, line 43 See: Decoded Returns: The Decoded object Type Decoded getIteration() Source: Encoded.js, line 104 Returns: Type Number getKey() Source: Encoded.js, line 68 Returns: Type Buffer getSalt() Source: Encoded.js, line 86 Returns: Type Buffer setIteration(iter) Parameters: Name Type Description iter Number Source: Encoded.js, line 113 setKey(key) Parameters: Name Type Description key Buffer Source: Encoded.js, line 77 setSalt(salt) Parameters: Name Type Description salt Buffer Source: Encoded.js, line 95 toString(enc) The hash string has the format iter:salt:key. Parameters: Name Type Description enc String Encoding scheme to be used Source: Encoded.js, line 58 See: Decoded#toString × Search results Close "},"Hasher.html":{"id":"Hasher.html","title":"Class: Hasher","body":" DocStrap Classes DecodedEncodedHasher Class: Hasher Hasher new Hasher() Creates and validates hashes. By default, this class uses 30,000 iterations, Hexadecimal encoding scheme, SHA-512 hashing method, and generates a 512-byte key. Source: Hasher.js, line 17 Members &lt;inner&gt; saltByte :Number Length of the salt in bytes Type: Number Source: Hasher.js, line 29 Methods generateSalt(callback [, urand]) Parameters: Name Type Argument Default Description callback Hasher~saltCallback Handles the randomly generated salt urand Boolean &lt;optional&gt; true Determines whether to use /dev/urandom or the time stamp as the random source Source: Hasher.js, line 43 hash(pwd, callback [, urand]) Hashes the provided pass-phrase Parameters: Name Type Argument Default Description pwd String Password to hash callback Hasher~hashCallback Handles the hashed object urand Boolean &lt;optional&gt; true Determines whether to use /dev/urandom or the time stamp as the random source Source: Hasher.js, line 66 validate(new_, old, callback [, enc]) Parameters: Name Type Argument Description new_ String Given pass-phrase old String The encoded hash string to compare to callback Hasher-validatorCallback Handles the validation result enc String &lt;optional&gt; The encoding scheme to be used (uses hasher.encoding as default) Source: Hasher.js, line 99 Example // Create a hash hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { const old = hashed.toString(hasher.encoding); // Generate hash string with default encoding scheme hasher.validate(&quot;password&quot;, old, (valid) =&gt; { assert.equal(valid, true); }); }); Type Definitions hashCallback(err, hashed) This callback takes the generated hash as an Encoded object. It also handles any errors from the PBKDF2 process. Parameters: Name Type Description err Object hashed Encoded The hashed object Source: Hasher.js, line 75 See: Encoded saltCallback(salt) This callback takes the randomly generated salt and allows it to be handled appropriately. Parameters: Name Type Description salt Buffer Randomly generated salt Source: Hasher.js, line 51 validatorCallback(valid) This callback handles the validation result. Parameters: Name Type Description valid Boolean Validation test result Source: Hasher.js, line 108 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
