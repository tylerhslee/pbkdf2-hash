<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"docs_scripts_fulltext-search-ui.js.html":{"id":"docs_scripts_fulltext-search-ui.js.html","title":"Source: docs/scripts/fulltext-search-ui.js","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Source: docs/scripts/fulltext-search-ui.js window.SearcherDisplay = (function($) { /** * This class provides support for displaying quick search text results to users. */ function SearcherDisplay() { } SearcherDisplay.prototype.init = function() { this._displayQuickSearch(); }; /** * This method creates the quick text search entry in navigation menu and wires all required events. */ SearcherDisplay.prototype._displayQuickSearch = function() { var quickSearch = $(document.createElement(&quot;iframe&quot;)), body = $(&quot;body&quot;), self = this; quickSearch.attr(&quot;src&quot;, &quot;quicksearch.html&quot;); quickSearch.css(&quot;width&quot;, &quot;0px&quot;); quickSearch.css(&quot;height&quot;, &quot;0px&quot;); body.append(quickSearch); $(window).on(&quot;message&quot;, function(msg) { var msgData = msg.originalEvent.data; if (msgData.msgid != &quot;docstrap.quicksearch.done&quot;) { return; } var results = msgData.results || []; self._displaySearchResults(results); }); function startSearch() { var searchTerms = $('#search-input').prop(&quot;value&quot;); if (searchTerms) { quickSearch[0].contentWindow.postMessage({ &quot;searchTerms&quot;: searchTerms, &quot;msgid&quot;: &quot;docstrap.quicksearch.start&quot; }, &quot;*&quot;); } } $('#search-input').on('keyup', function(evt) { if (evt.keyCode != 13) { return; } startSearch(); return false; }); $('#search-submit').on('click', function() { startSearch(); return false; }); }; /** * This method displays the quick text search results in a modal dialog. */ SearcherDisplay.prototype._displaySearchResults = function(results) { var resultsHolder = $($(&quot;#searchResults&quot;).find(&quot;.modal-body&quot;)), fragment = document.createDocumentFragment(), resultsList = document.createElement(&quot;ul&quot;); resultsHolder.empty(); for (var idx = 0; idx &lt; results.length; idx++) { var result = results[idx], item = document.createElement(&quot;li&quot;), link = document.createElement(&quot;a&quot;); link.href = result.id; link.innerHTML = result.title; item.appendChild(link) resultsList.appendChild(item); } fragment.appendChild(resultsList); resultsHolder.append(fragment); $(&quot;#searchResults&quot;).modal({&quot;show&quot;: true}); }; return new SearcherDisplay(); })($); × Search results Close "},"template_static_scripts_fulltext-search-ui.js.html":{"id":"template_static_scripts_fulltext-search-ui.js.html","title":"Source: template/static/scripts/fulltext-search-ui.js","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Source: template/static/scripts/fulltext-search-ui.js window.SearcherDisplay = (function($) { /** * This class provides support for displaying quick search text results to users. */ function SearcherDisplay() { } SearcherDisplay.prototype.init = function() { this._displayQuickSearch(); }; /** * This method creates the quick text search entry in navigation menu and wires all required events. */ SearcherDisplay.prototype._displayQuickSearch = function() { var quickSearch = $(document.createElement(&quot;iframe&quot;)), body = $(&quot;body&quot;), self = this; quickSearch.attr(&quot;src&quot;, &quot;quicksearch.html&quot;); quickSearch.css(&quot;width&quot;, &quot;0px&quot;); quickSearch.css(&quot;height&quot;, &quot;0px&quot;); body.append(quickSearch); $(window).on(&quot;message&quot;, function(msg) { var msgData = msg.originalEvent.data; if (msgData.msgid != &quot;docstrap.quicksearch.done&quot;) { return; } var results = msgData.results || []; self._displaySearchResults(results); }); function startSearch() { var searchTerms = $('#search-input').prop(&quot;value&quot;); if (searchTerms) { quickSearch[0].contentWindow.postMessage({ &quot;searchTerms&quot;: searchTerms, &quot;msgid&quot;: &quot;docstrap.quicksearch.start&quot; }, &quot;*&quot;); } } $('#search-input').on('keyup', function(evt) { if (evt.keyCode != 13) { return; } startSearch(); return false; }); $('#search-submit').on('click', function() { startSearch(); return false; }); }; /** * This method displays the quick text search results in a modal dialog. */ SearcherDisplay.prototype._displaySearchResults = function(results) { var resultsHolder = $($(&quot;#searchResults&quot;).find(&quot;.modal-body&quot;)), fragment = document.createDocumentFragment(), resultsList = document.createElement(&quot;ul&quot;); resultsHolder.empty(); for (var idx = 0; idx &lt; results.length; idx++) { var result = results[idx], item = document.createElement(&quot;li&quot;), link = document.createElement(&quot;a&quot;); link.href = result.id; link.innerHTML = result.title; item.appendChild(link) resultsList.appendChild(item); } fragment.appendChild(resultsList); resultsHolder.append(fragment); $(&quot;#searchResults&quot;).modal({&quot;show&quot;: true}); }; return new SearcherDisplay(); })($); × Search results Close "},"lib_Decoded.js.html":{"id":"lib_Decoded.js.html","title":"Source: lib/Decoded.js","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Source: lib/Decoded.js &quot;use strict&quot;; const Encoded = require(&quot;./Encoded&quot;); /** * @constructor * @desc Stores hashed pass-phrase as decoded Strings. * @param {String} key - The decoded key * @param {String} salt - The decoded salt * @param {Number} iter - The number of PBKDF2 iterations */ function Decoded (key, salt, iter) { this.key = key; this.salt = salt; this.iter = iter; } /** * @method * @memberof Decoded * @desc Encodes the Decoded object into an Encoded object. * @param {String} enc - Encoding scheme to be used * @returns {Encoded} The Encoded object * @see Encoded */ Decoded.prototype.encode = function (enc) { const encodedKey = new Buffer(this.key, enc); const encodedSalt = new Buffer(this.salt, enc); const iter = this.iter; return new Encoded(encodedKey, encodedSalt, iter); } /** * @method * @memberof Decoded * @desc Concatenates the stored hash data into a hash string. * @desc The hash string has the format `iter:salt:key`. * @returns {String} The hash string */ Decoded.prototype.toString = function () { return `${this.iter}:${this.salt}:${this.key}`; } /** * @method * @memberof Decoded * @returns {String} */ Decoded.prototype.getKey = function () { return this.key; } /** * @method * @memberof Decoded * @param {Buffer} key */ Decoded.prototype.setKey = function (key) { this.key = key; } /** * @method * @memberof Decoded * @returns {Buffer} */ Decoded.prototype.getSalt = function () { return this.salt; } /** * @method * @memberof Decoded * @param {Buffer} salt */ Decoded.prototype.setSalt = function (salt) { this.salt = salt; } /** * @method * @memberof Decoded * @returns {Number} */ Decoded.prototype.getIteration = function () { return this.iter; } /** * @method * @memberof Decoded * @param {Number} iter */ Decoded.prototype.setIteration = function (iter) { this.iter = iter; } module.exports = Decoded; × Search results Close "},"lib_Encoded.js.html":{"id":"lib_Encoded.js.html","title":"Source: lib/Encoded.js","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Source: lib/Encoded.js &quot;use strict&quot;; const Decoded = require(&quot;./Decoded&quot;); /** * @constructor * @desc Stores hashed pass-phrase as Buffers. * @param {Buffer} key - The hashed key * @param {Buffer} salt - The hashed salt * @param {Number} iter - The Number of PBKDF2 iterations */ function Encoded (key, salt, iter) { this.key = key; this.salt = salt; this.iter = iter; } /** * @method * @memberof Encoded * @desc Parses a hash string into an Encoded object. * @param {String} pass - The hash string * @param {String} enc - Encoding scheme to be used * @returns {Encoded} The Encoded object */ Encoded.parse = function (pass, enc) { const arr = pass.split(&quot;:&quot;); const key = new Buffer(arr[2], enc); const salt = new Buffer(arr[1], enc); const iter = parseInt(arr[0]); return new Encoded(key, salt, iter); }; /** * @method * @memberof Encoded * @desc Decodes the Encoded object into a Decoded object. * @param {String} enc - Encoding scheme to be used * @returns {Decoded} The Decoded object * @see Decoded */ Encoded.prototype.decode = function (enc) { const decodedKey = this.getKey().toString(enc).toUpperCase(); const decodedSalt = this.getSalt().toString(enc).toUpperCase(); const iter = this.getIteration(); return new Decoded(decodedKey, decodedSalt, iter); } /** * @method * @memberof Encoded * @desc Converts the stored hash data into a hash string. * @desc The hash string has the format &lt;code&gt;iter:salt:key&lt;/code&gt;. * @param {String} enc - Encoding scheme to be used * @see Decoded#toString */ Encoded.prototype.toString = function (enc) { const decoded = this.decode(enc); return decoded.toString(); } /** * @method * @memberof Encoded * @returns {Buffer} */ Encoded.prototype.getKey = function () { return this.key; } /** * @method * @memberof Encoded * @param {Buffer} key */ Encoded.prototype.setKey = function (key) { this.key = key; } /** * @method * @memberof Encoded * @returns {Buffer} */ Encoded.prototype.getSalt = function () { return this.salt; } /** * @method * @memberof Encoded * @param {Buffer} salt */ Encoded.prototype.setSalt = function (salt) { this.salt = salt; } /** * @method * @memberof Encoded * @returns {Number} */ Encoded.prototype.getIteration = function () { return this.iter; } /** * @method * @memberof Encoded * @param {Number} iter */ Encoded.prototype.setIteration = function (iter) { this.iter = iter; } module.exports = Encoded; × Search results Close "},"lib_Hasher.js.html":{"id":"lib_Hasher.js.html","title":"Source: lib/Hasher.js","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Source: lib/Hasher.js &quot;use strict&quot;; const crypto = require(&quot;crypto&quot;); const timeSource = require(&quot;randbytes&quot;).timeRandom.getInstance(); let randomSource = {}; if (process.platform !== &quot;win32&quot;) randomSource = require(&quot;randbytes&quot;).urandom.getInstance(); const Encoded = require(&quot;./Encoded&quot;); const Decoded = require(&quot;./Decoded&quot;); /** * @constructor * @desc Creates and validates hashes. * @params {Number} iteration - Number of iterations to run * @params {String} encoding - The default encoding scheme to be used * @params {String} hashMethod - The default hashing method to be implemented by PBKDF2 * @params {Number} keyLength - The length of the generated hash in bytes */ function Hasher (iteration, encoding, hashMethod, keyLength) { // Type validation (dotenv gives iteration as string, so just to be careful) if (typeof iteration !== &quot;number&quot;) throw Error(&quot;Iteration must be number&quot;); this.iter = iteration; this.hashMethod = hashMethod; if (typeof keyLength !== &quot;number&quot;) throw Error(&quot;Key length must be number&quot;); this.keylen = keyLength; this.encoding = encoding; /** * @type {Number} * @name Hasher~saltByte * @desc Length of the salt in bytes */ // Generate 64-byte salt (256/8 = 64) const saltByte = 64; /** * @method * @instance * @param {Hasher~saltCallback} callback - Handles the randomly generated salt * @param {Boolean} [urand=true] - Determines whether to use &lt;code&gt;/dev/urandom&lt;/code&gt; or the time stamp as the random source */ this.generateSalt = function (callback, urand=true) { let source = randomSource; if (!urand) source = timeSource; source.getRandomBytes(saltByte, (salt) =&gt; { callback(salt); }); } /** * This callback takes the randomly generated salt and allows it to be handled appropriately. * @callback Hasher~saltCallback * @param {Buffer} salt - Randomly generated salt */ }; /** * @method * @memberof Hasher * @desc Hashes the provided pass-phrase * @param {String} pwd - Password to hash * @param {Hasher~hashCallback} callback - Handles the hashed object * @param {Boolean} [urand=true] - Determines whether to use &lt;code&gt;/dev/urandom&lt;/code&gt; or the time stamp as the random source */ Hasher.prototype.hash = function (pwd, callback, urand=true) { this.generateSalt((salt) =&gt; { crypto.pbkdf2(pwd, salt, this.iter, this.keylen, this.hashMethod, (err, key) =&gt; { if (err) console.error(err); const hashed = new Encoded(key, salt, this.iter); callback(err, hashed); }); }, urand) }; /** * This callback takes the generated hash as an {@link Encoded} object. It also handles any errors from the PBKDF2 process. * @callback Hasher~hashCallback * @param {Object} err * @param {Encoded} hashed - The hashed object * @see Encoded */ /** * @method * @memberof Hasher * @param {String} new_ - Given pass-phrase * @param {String} old - The encoded hash string to compare to * @param {Hasher-validatorCallback} callback - Handles the validation result * @param {String=} - The encoding scheme to be used (uses &lt;code&gt;hasher.encoding&lt;/code&gt; as default) * @example * // Create a hash * hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { * const old = hashed.toString(hasher.encoding); // Generate hash string with default encoding scheme * hasher.validate(&quot;password&quot;, old, (valid) =&gt; { * assert.equal(valid, true); * }); * }); */ Hasher.prototype.validate = function (new_, old, callback, enc) { const oldHash = Encoded.parse(old, enc || this.encoding); crypto.pbkdf2(new_, oldHash.getSalt(), this.iter, this.keylen, this.hashMethod, (err, key) =&gt; { if (err) console.error(err); let valid = false; if (key.length === oldHash.getKey().length &amp;&amp; key.equals(oldHash.getKey())) valid = true; callback(valid); }); }; /** * This callback handles the validation result. * @callback Hasher~validatorCallback * @param {Boolean} valid - Validation test result */ module.exports = Hasher; × Search results Close "},"template_publish.js.html":{"id":"template_publish.js.html","title":"Source: template/publish.js","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Source: template/publish.js &quot;use strict&quot;; /** * @module template/publish * @type {*} */ /*global env: true */ var template = require('jsdoc/template'), doop = require('jsdoc/util/doop'), fs = require('jsdoc/fs'), _ = require('underscore'), path = require('jsdoc/path'), taffy = require('taffydb').taffy, handle = require('jsdoc/util/error').handle, helper = require('jsdoc/util/templateHelper'), moment = require(&quot;moment&quot;), htmlsafe = helper.htmlsafe, sanitizeHtml = require('sanitize-html'), linkto = helper.linkto, resolveAuthorLinks = helper.resolveAuthorLinks, scopeToPunc = helper.scopeToPunc, hasOwnProp = Object.prototype.hasOwnProperty, conf = env.conf.templates || {}, data, view, outdir = env.opts.destination, searchEnabled = conf.search !== false; var globalUrl = helper.getUniqueFilename('global'); var indexUrl = helper.getUniqueFilename('index'); var navOptions = { includeDate: conf.includeDate !== false, logoFile: conf.logoFile, systemName: conf.systemName || &quot;Documentation&quot;, navType: conf.navType || &quot;vertical&quot;, footer: conf.footer || &quot;&quot;, copyright: conf.copyright || &quot;&quot;, theme: conf.theme || &quot;simplex&quot;, syntaxTheme: conf.syntaxTheme || &quot;default&quot;, linenums: conf.linenums, collapseSymbols: conf.collapseSymbols || false, inverseNav: conf.inverseNav, outputSourceFiles: conf.outputSourceFiles === true, sourceRootPath: conf.sourceRootPath, disablePackagePath: conf.disablePackagePath, outputSourcePath: conf.outputSourcePath, dateFormat: conf.dateFormat, analytics: conf.analytics || null, methodHeadingReturns: conf.methodHeadingReturns === true, sort: conf.sort, search: searchEnabled }; var searchableDocuments = {}; var navigationMaster = { index: { title: navOptions.systemName, link: indexUrl, members: [] }, namespace: { title: &quot;Namespaces&quot;, link: helper.getUniqueFilename(&quot;namespaces.list&quot;), members: [] }, module: { title: &quot;Modules&quot;, link: helper.getUniqueFilename(&quot;modules.list&quot;), members: [] }, class: { title: &quot;Classes&quot;, link: helper.getUniqueFilename('classes.list'), members: [] }, mixin: { title: &quot;Mixins&quot;, link: helper.getUniqueFilename(&quot;mixins.list&quot;), members: [] }, event: { title: &quot;Events&quot;, link: helper.getUniqueFilename(&quot;events.list&quot;), members: [] }, interface: { title: &quot;Interfaces&quot;, link: helper.getUniqueFilename(&quot;interfaces.list&quot;), members: [] }, tutorial: { title: &quot;Tutorials&quot;, link: helper.getUniqueFilename(&quot;tutorials.list&quot;), members: [] }, global: { title: &quot;Global&quot;, link: globalUrl, members: [] }, external: { title: &quot;Externals&quot;, link: helper.getUniqueFilename(&quot;externals.list&quot;), members: [] } }; function find(spec) { return helper.find(data, spec); } function tutoriallink(tutorial) { return helper.toTutorial(tutorial, null, { tag: 'em', classname: 'disabled', prefix: 'Tutorial: ' }); } function getAncestorLinks(doclet) { return helper.getAncestorLinks(data, doclet); } function hashToLink(doclet, hash) { if (!/^(#.+)/.test(hash)) { return hash; } var url = helper.createLink(doclet); url = url.replace(/(#.+|$)/, hash); return '&lt;a href=&quot;' + url + '&quot;&gt;' + hash + '&lt;/a&gt;'; } function needsSignature(doclet) { var needsSig = false; // function and class definitions always get a signature if (doclet.kind === 'function' || doclet.kind === 'class') { needsSig = true; } // typedefs that contain functions get a signature, too else if (doclet.kind === 'typedef' &amp;&amp; doclet.type &amp;&amp; doclet.type.names &amp;&amp; doclet.type.names.length) { for (var i = 0, l = doclet.type.names.length; i &lt; l; i++) { if (doclet.type.names[i].toLowerCase() === 'function') { needsSig = true; break; } } } return needsSig; } function addSignatureParams(f) { var optionalClass = 'optional'; var params = helper.getSignatureParams(f, optionalClass); f.signature = (f.signature || '') + '('; for (var i = 0, l = params.length; i &lt; l; i++) { var element = params[i]; var seperator = (i &gt; 0) ? ', ' : ''; if (!new RegExp(&quot;class=[\\&quot;|']&quot;+optionalClass+&quot;[\\&quot;|']&quot;).test(element)) { f.signature += seperator + element; } else { var regExp = new RegExp(&quot;&lt;span class=[\\&quot;|']&quot;+optionalClass+&quot;[\\&quot;|']&gt;(.*?)&lt;\\\\/span&gt;&quot;, &quot;i&quot;); f.signature += element.replace(regExp, &quot; $`[&quot;+seperator+&quot;$1$']&quot;); } } f.signature += ')'; } function addSignatureReturns(f) { if (navOptions.methodHeadingReturns) { var returnTypes = helper.getSignatureReturns(f); f.signature = '&lt;span class=&quot;signature&quot;&gt;' + (f.signature || '') + '&lt;/span&gt;' + '&lt;span class=&quot;type-signature&quot;&gt;' + (returnTypes.length ? ' &amp;rarr; {' + returnTypes.join('|') + '}' : '') + '&lt;/span&gt;'; } else { f.signature = f.signature || ''; } } function addSignatureTypes(f) { var types = helper.getSignatureTypes(f); f.signature = (f.signature || '') + '&lt;span class=&quot;type-signature&quot;&gt;' + (types.length ? ' :' + types.join('|') : '') + '&lt;/span&gt;'; } function addAttribs(f) { var attribs = helper.getAttribs(f); f.attribs = '&lt;span class=&quot;type-signature&quot;&gt;' + htmlsafe(attribs.length ? '&lt;' + attribs.join(', ') + '&gt; ' : '') + '&lt;/span&gt;'; } function shortenPaths(files, commonPrefix) { // // always use forward slashes // var regexp = new RegExp( '\\\\\\\\', 'g' ); // // var prefix = commonPrefix.toLowerCase().replace( regexp, &quot;/&quot; ); // // Object.keys( files ).forEach( function ( file ) { // files[file].shortened = files[file] // .resolved // .toLowerCase() // .replace( regexp, '/' ) // .replace( prefix, '' ); // } ); Object.keys(files).forEach(function(file) { files[file].shortened = files[file].resolved.replace(commonPrefix, '') // always use forward slashes .replace(/\\\\/g, '/'); }); return files; } function getPathFromDoclet(doclet) { if (!doclet.meta) { return; } return path.normalize(doclet.meta.path &amp;&amp; doclet.meta.path !== 'null' ? doclet.meta.path + '/' + doclet.meta.filename : doclet.meta.filename); } function searchData(html) { var startOfContent = html.indexOf(&quot;&lt;div class=\\&quot;container\\&quot;&gt;&quot;); if (startOfContent &gt; 0) { var startOfSecondContent = html.indexOf(&quot;&lt;div class=\\&quot;container\\&quot;&gt;&quot;, startOfContent + 2); if (startOfSecondContent &gt; 0) { startOfContent = startOfSecondContent; } html = html.slice(startOfContent); } var endOfContent = html.indexOf(&quot;&lt;span class=\\&quot;copyright\\&quot;&gt;&quot;); if (endOfContent &gt; 0) { html = html.substring(0, endOfContent); } var stripped = sanitizeHtml(html, {allowedTags: [], allowedAttributes: []}); stripped = stripped.replace(/\\s+/g, ' '); return stripped; } function generate(docType, title, docs, filename, resolveLinks) { resolveLinks = resolveLinks === false ? false : true; var docData = { title: title, docs: docs, docType: docType }; var outpath = path.join(outdir, filename), html = view.render('container.tmpl', docData); if (resolveLinks) { html = helper.resolveLinks(html); // turn {@link foo} into &lt;a href=&quot;foodoc.html&quot;&gt;foo&lt;/a&gt; } if (searchEnabled) { searchableDocuments[filename] = { &quot;id&quot;: filename, &quot;title&quot;: title, &quot;body&quot;: searchData(html) }; } fs.writeFileSync(outpath, html, 'utf8'); } function generateSourceFiles(sourceFiles) { Object.keys(sourceFiles).forEach(function(file) { var source; // links are keyed to the shortened path in each doclet's `meta.shortpath` property var sourceOutfile = helper.getUniqueFilename(sourceFiles[file].shortened); helper.registerLink(sourceFiles[file].shortened, sourceOutfile); try { source = { kind: 'source', code: helper.htmlsafe(fs.readFileSync(sourceFiles[file].resolved, 'utf8')) }; } catch (e) { handle(e); } generate('source', 'Source: ' + sourceFiles[file].shortened, [source], sourceOutfile, false); }); } /** * Look for classes or functions with the same name as modules (which indicates that the module * exports only that class or function), then attach the classes or functions to the `module` * property of the appropriate module doclets. The name of each class or function is also updated * for display purposes. This function mutates the original arrays. * * @private * @param {Array.&lt;module:jsdoc/doclet.Doclet&gt;} doclets - The array of classes and functions to * check. * @param {Array.&lt;module:jsdoc/doclet.Doclet&gt;} modules - The array of module doclets to search. */ function attachModuleSymbols(doclets, modules) { var symbols = {}; // build a lookup table doclets.forEach(function(symbol) { symbols[symbol.longname] = symbols[symbol.longname] || []; symbols[symbol.longname].push(symbol); }); return modules.map(function(module) { if (symbols[module.longname]) { module.modules = symbols[module.longname] // Only show symbols that have a description. Make an exception for classes, because // we want to show the constructor-signature heading no matter what. .filter(function(symbol) { return symbol.description || symbol.kind === 'class'; }) .map(function(symbol) { symbol = doop(symbol); if (symbol.kind === 'class' || symbol.kind === 'function') { symbol.name = symbol.name.replace('module:', '(require(&quot;') + '&quot;))'; } return symbol; }); } }); } /** * Create the navigation sidebar. * @param {object} members The members that will be used to create the sidebar. * @param {array&lt;object&gt;} members.classes * @param {array&lt;object&gt;} members.externals * @param {array&lt;object&gt;} members.globals * @param {array&lt;object&gt;} members.mixins * @param {array&lt;object&gt;} members.interfaces * @param {array&lt;object&gt;} members.modules * @param {array&lt;object&gt;} members.namespaces * @param {array&lt;object&gt;} members.tutorials * @param {array&lt;object&gt;} members.events * @return {string} The HTML for the navigation sidebar. */ function buildNav(members) { var seen = {}; var nav = navigationMaster; if (members.modules.length) { members.modules.forEach(function(m) { if (!hasOwnProp.call(seen, m.longname)) { nav.module.members.push(linkto(m.longname, m.longname.replace(&quot;module:&quot;, &quot;&quot;))); } seen[m.longname] = true; }); } if (members.externals.length) { members.externals.forEach(function(e) { if (!hasOwnProp.call(seen, e.longname)) { nav.external.members.push(linkto(e.longname, e.name.replace(/(^&quot;|&quot;$)/g, ''))); } seen[e.longname] = true; }); } if (members.classes.length) { members.classes.forEach(function(c) { if (!hasOwnProp.call(seen, c.longname)) { nav.class.members.push(linkto(c.longname, c.longname.replace(&quot;module:&quot;, &quot;&quot;))); } seen[c.longname] = true; }); } if (members.events.length) { members.events.forEach(function(e) { if (!hasOwnProp.call(seen, e.longname)) { nav.event.members.push(linkto(e.longname, e.longname.replace(&quot;module:&quot;, &quot;&quot;))); } seen[e.longname] = true; }); } if (members.namespaces.length) { members.namespaces.forEach(function(n) { if (!hasOwnProp.call(seen, n.longname)) { nav.namespace.members.push(linkto(n.longname, n.longname.replace(&quot;module:&quot;, &quot;&quot;))); } seen[n.longname] = true; }); } if (members.mixins.length) { members.mixins.forEach(function(m) { if (!hasOwnProp.call(seen, m.longname)) { nav.mixin.members.push(linkto(m.longname, m.longname.replace(&quot;module:&quot;, &quot;&quot;))); } seen[m.longname] = true; }); } if (members.interfaces &amp;&amp; members.interfaces.length) { members.interfaces.forEach(function(m) { if (!hasOwnProp.call(seen, m.longname)) { nav.interface.members.push(linkto(m.longname, m.longname.replace(&quot;module:&quot;, &quot;&quot;))); } seen[m.longname] = true; }); } if (members.tutorials.length) { members.tutorials.forEach(function(t) { nav.tutorial.members.push(tutoriallink(t.name)); }); } if (members.globals.length) { members.globals.forEach(function(g) { if (g.kind !== 'typedef' &amp;&amp; !hasOwnProp.call(seen, g.longname)) { nav.global.members.push(linkto(g.longname, g.longname.replace(&quot;module:&quot;, &quot;&quot;))); } seen[g.longname] = true; }); // even if there are no links, provide a link to the global page. if (nav.global.members.length === 0) { nav.global.members.push(linkto(&quot;global&quot;, &quot;Global&quot;)); } } var topLevelNav = []; _.each(nav, function(entry, name) { if (entry.members.length &gt; 0 &amp;&amp; name !== &quot;index&quot;) { topLevelNav.push({ title: entry.title, link: entry.link, members: entry.members }); } }); nav.topLevelNav = topLevelNav; } /** @param {TAFFY} taffyData See &lt;http://taffydb.com/&gt;. @param {object} opts @param {Tutorial} tutorials */ exports.publish = function(taffyData, opts, tutorials) { data = taffyData; conf['default'] = conf['default'] || {}; var templatePath = opts.template; view = new template.Template(templatePath + '/tmpl'); // claim some special filenames in advance, so the All-Powerful Overseer of Filename Uniqueness // doesn't try to hand them out later // var indexUrl = helper.getUniqueFilename( 'index' ); // don't call registerLink() on this one! 'index' is also a valid longname // var globalUrl = helper.getUniqueFilename( 'global' ); helper.registerLink('global', globalUrl); // set up templating // set up templating view.layout = conf['default'].layoutFile ? path.getResourcePath(path.dirname(conf['default'].layoutFile), path.basename(conf['default'].layoutFile) ) : 'layout.tmpl'; // set up tutorials for helper helper.setTutorials(tutorials); data = helper.prune(data); var sortOption = navOptions.sort === undefined ? opts.sort : navOptions.sort; sortOption = sortOption === undefined ? true : sortOption; sortOption = sortOption === true ? 'longname, version, since' : sortOption; if (sortOption) { data.sort(sortOption); } helper.addEventListeners(data); var sourceFiles = {}; var sourceFilePaths = []; data().each(function(doclet) { doclet.attribs = ''; if (doclet.examples) { doclet.examples = doclet.examples.map(function(example) { var caption, lang; // allow using a markdown parser on the examples captions (surrounded by useless HTML p tags) if (example.match(/^\\s*(&lt;p&gt;)?&lt;caption&gt;([\\s\\S]+?)&lt;\\/caption&gt;(\\s*)([\\s\\S]+?)(&lt;\\/p&gt;)?$/i)) { caption = RegExp.$2; example = RegExp.$4 + (RegExp.$1 ? '' : RegExp.$5); } var lang = /{@lang (.*?)}/.exec(example); if (lang &amp;&amp; lang[1]) { example = example.replace(lang[0], &quot;&quot;); lang = lang[1]; } else { lang = null; } return { caption: caption || '', code: example, lang: lang || &quot;javascript&quot; }; }); } if (doclet.see) { doclet.see.forEach(function(seeItem, i) { doclet.see[i] = hashToLink(doclet, seeItem); }); } // build a list of source files var sourcePath; if (doclet.meta) { sourcePath = getPathFromDoclet(doclet); sourceFiles[sourcePath] = { resolved: sourcePath, shortened: null }; //Check to see if the array of source file paths already contains // the source path, if not then add it if (sourceFilePaths.indexOf(sourcePath) === -1) { sourceFilePaths.push(sourcePath) } } }); // update outdir if necessary, then create outdir var packageInfo = (find({ kind: 'package' }) || [])[0]; if (navOptions.disablePackagePath !== true &amp;&amp; packageInfo &amp;&amp; packageInfo.name) { if (packageInfo.version) { outdir = path.join(outdir, packageInfo.name, packageInfo.version); } else { outdir = path.join(outdir, packageInfo.name); } } fs.mkPath(outdir); // copy the template's static files to outdir var fromDir = path.join( templatePath, 'static' ); var staticFiles = fs.ls( fromDir, 3 ); staticFiles.forEach( function ( fileName ) { var toDir = fs.toDir( fileName.replace( fromDir, outdir ) ); fs.mkPath( toDir ); fs.copyFileSync( fileName, toDir ); } ); // copy user-specified static files to outdir var staticFilePaths; var staticFileFilter; var staticFileScanner; if (conf.default.staticFiles) { // The canonical property name is `include`. We accept `paths` for backwards compatibility // with a bug in JSDoc 3.2.x. staticFilePaths = conf.default.staticFiles.include || conf.default.staticFiles.paths || []; staticFileFilter = new (require('jsdoc/src/filter')).Filter(conf.default.staticFiles); staticFileScanner = new (require('jsdoc/src/scanner')).Scanner(); staticFilePaths.forEach(function(filePath) { var extraStaticFiles = staticFileScanner.scan([filePath], 10, staticFileFilter); extraStaticFiles.forEach(function(fileName) { var sourcePath = fs.toDir(filePath); var toDir = fs.toDir( fileName.replace(sourcePath, outdir) ); fs.mkPath(toDir); fs.copyFileSync(fileName, toDir); }); }); } if (sourceFilePaths.length) { var payload = navOptions.sourceRootPath; if (!payload) { payload = path.commonPrefix(sourceFilePaths); } sourceFiles = shortenPaths(sourceFiles, payload); } data().each(function(doclet) { var url = helper.createLink(doclet); helper.registerLink(doclet.longname, url); // add a shortened version of the full path var docletPath; if (doclet.meta) { docletPath = getPathFromDoclet(doclet); if (!_.isEmpty(sourceFiles[docletPath])) { docletPath = sourceFiles[docletPath].shortened; if (docletPath) { doclet.meta.shortpath = docletPath; } } } }); data().each(function(doclet) { var url = helper.longnameToUrl[doclet.longname]; if (url.indexOf('#') &gt; -1) { doclet.id = helper.longnameToUrl[doclet.longname].split(/#/).pop(); } else { doclet.id = doclet.name; } if (needsSignature(doclet)) { addSignatureParams(doclet); addSignatureReturns(doclet); addAttribs(doclet); } }); // do this after the urls have all been generated data().each(function(doclet) { doclet.ancestors = getAncestorLinks(doclet); if (doclet.kind === 'member') { addSignatureTypes(doclet); addAttribs(doclet); } if (doclet.kind === 'constant') { addSignatureTypes(doclet); addAttribs(doclet); doclet.kind = 'member'; } }); var members = helper.getMembers(data); members.tutorials = tutorials.children; // add template helpers view.find = find; view.linkto = linkto; view.resolveAuthorLinks = resolveAuthorLinks; view.tutoriallink = tutoriallink; view.htmlsafe = htmlsafe; view.moment = moment; // once for all buildNav(members); view.nav = navigationMaster; view.navOptions = navOptions; attachModuleSymbols(find({ kind: ['class', 'function'], longname: { left: 'module:' } }), members.modules); // only output pretty-printed source files if requested; do this before generating any other // pages, so the other pages can link to the source files if (navOptions.outputSourceFiles) { generateSourceFiles(sourceFiles); } if (members.globals.length) { generate('global', 'Global', [{ kind: 'globalobj' }], globalUrl); } // some browsers can't make the dropdown work if (view.nav.module &amp;&amp; view.nav.module.members.length) { generate('module', view.nav.module.title, [{ kind: 'sectionIndex', contents: view.nav.module }], navigationMaster.module.link); } if (view.nav.class &amp;&amp; view.nav.class.members.length) { generate('class', view.nav.class.title, [{ kind: 'sectionIndex', contents: view.nav.class }], navigationMaster.class.link); } if (view.nav.namespace &amp;&amp; view.nav.namespace.members.length) { generate('namespace', view.nav.namespace.title, [{ kind: 'sectionIndex', contents: view.nav.namespace }], navigationMaster.namespace.link); } if (view.nav.mixin &amp;&amp; view.nav.mixin.members.length) { generate('mixin', view.nav.mixin.title, [{ kind: 'sectionIndex', contents: view.nav.mixin }], navigationMaster.mixin.link); } if (view.nav.interface &amp;&amp; view.nav.interface.members.length) { generate('interface', view.nav.interface.title, [{ kind: 'sectionIndex', contents: view.nav.interface }], navigationMaster.interface.link); } if (view.nav.external &amp;&amp; view.nav.external.members.length) { generate('external', view.nav.external.title, [{ kind: 'sectionIndex', contents: view.nav.external }], navigationMaster.external.link); } if (view.nav.tutorial &amp;&amp; view.nav.tutorial.members.length) { generate('tutorial', view.nav.tutorial.title, [{ kind: 'sectionIndex', contents: view.nav.tutorial }], navigationMaster.tutorial.link); } // index page displays information from package.json and lists files var files = find({ kind: 'file' }), packages = find({ kind: 'package' }); generate('index', 'Index', packages.concat( [{ kind: 'mainpage', readme: opts.readme, longname: (opts.mainpagetitle) ? opts.mainpagetitle : 'Main Page' }] ).concat(files), indexUrl); // set up the lists that we'll use to generate pages var classes = taffy(members.classes); var modules = taffy(members.modules); var namespaces = taffy(members.namespaces); var mixins = taffy(members.mixins); var interfaces = taffy(members.interfaces); var externals = taffy(members.externals); for (var longname in helper.longnameToUrl) { if (hasOwnProp.call(helper.longnameToUrl, longname)) { var myClasses = helper.find(classes, { longname: longname }); if (myClasses.length) { generate('class', 'Class: ' + myClasses[0].name, myClasses, helper.longnameToUrl[longname]); } var myModules = helper.find(modules, { longname: longname }); if (myModules.length) { generate('module', 'Module: ' + myModules[0].name, myModules, helper.longnameToUrl[longname]); } var myNamespaces = helper.find(namespaces, { longname: longname }); if (myNamespaces.length) { generate('namespace', 'Namespace: ' + myNamespaces[0].name, myNamespaces, helper.longnameToUrl[longname]); } var myMixins = helper.find(mixins, { longname: longname }); if (myMixins.length) { generate('mixin', 'Mixin: ' + myMixins[0].name, myMixins, helper.longnameToUrl[longname]); } var myInterfaces = helper.find(interfaces, { longname: longname }); if (myInterfaces.length) { generate('interface', 'Interface: ' + myInterfaces[0].name, myInterfaces, helper.longnameToUrl[longname]); } var myExternals = helper.find(externals, { longname: longname }); if (myExternals.length) { generate('external', 'External: ' + myExternals[0].name, myExternals, helper.longnameToUrl[longname]); } } } // TODO: move the tutorial functions to templateHelper.js function generateTutorial(title, tutorial, filename) { var tutorialData = { title: title, header: tutorial.title, content: tutorial.parse(), children: tutorial.children, docs: null }; var tutorialPath = path.join(outdir, filename), html = view.render('tutorial.tmpl', tutorialData); // yes, you can use {@link} in tutorials too! html = helper.resolveLinks(html); // turn {@link foo} into &lt;a href=&quot;foodoc.html&quot;&gt;foo&lt;/a&gt; if (searchEnabled) { searchableDocuments[filename] = { &quot;id&quot;: filename, &quot;title&quot;: title, &quot;body&quot;: searchData(html) }; } fs.writeFileSync(tutorialPath, html, 'utf8'); } // tutorials can have only one parent so there is no risk for loops function saveChildren(node) { node.children.forEach(function(child) { generateTutorial('Tutorial: ' + child.title, child, helper.tutorialToUrl(child.name)); saveChildren(child); }); } function generateQuickTextSearch(templatePath, searchableDocuments, navOptions) { var data = { searchableDocuments: JSON.stringify(searchableDocuments), navOptions: navOptions }; var tmplString = fs.readFileSync(templatePath + &quot;/quicksearch.tmpl&quot;).toString(), tmpl = _.template(tmplString); var html = tmpl(data), outpath = path.join(outdir, &quot;quicksearch.html&quot;); fs.writeFileSync(outpath, html, &quot;utf8&quot;); } saveChildren(tutorials); if (searchEnabled) { generateQuickTextSearch(templatePath + '/tmpl', searchableDocuments, navOptions); } }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Modules Classes Decoded Encoded Hasher × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Classes Classes Decoded Encoded Hasher × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Hashing with PBKDF2This package creates a hash using the PBKDF2 method. Random salts are generated using the randbytes package. It can be downloaded on npm here. UsageHasher objectThe Hasher object is what generates hashes. The salt is randomly generated through /dev/urandom. const pbkdf = require(&quot;pbkdf2-hash&quot;) , hasher = pbkdf.create(); hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { console.log(hashed.toString(hasher.encoding)); });The hasher can take 4 optional arguments: iteration, encoding, method, and keylen. By default, the following constructor is called upon the call to create(): const options = { iteration: 30000, encoding: &quot;hex&quot;, method: &quot;sha512&quot;, keylen: 512 }; const hasher = pbkdf.create(options); assert.equal(hasher.iteration, pbkdf.create().iteration); assert.equal(hasher.encoding, pbkdf.create().encoding); assert.equal(hasher.method, pbkdf.create().method); assert.equal(hashser.keylen, pbkdf.create().keylen);encoding is a convenience property to set a global encoding scheme across the project. It is a good way to keep track of your Strings and Buffers as they can get mixed up if one is not careful enough. If you are on a non-UNIX system, you can choose to generate random salt with a time stamp instead. For more information, check here. However, this is not recommended and should not be used unless absolutely necessary. Encoded and Decoded objects that store the hashed dataThe hash() method returns an Encoded object, which contains hashed data in Buffers. These data can be decoded into Decoded objects if string vales are needed. hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { console.log(hashed.toString(hasher.encoding)); // If you want a different encoding scheme... console.log(hashed.toString(&quot;utf8&quot;)); });It can also be used to parse an already stringified hash. hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { const h1 = hashed; const h2 = hashed.parse(hashed.toString(hasher.encoding), hasher.encoding); assert.equal(JSON.stringify(h1)).equal(JSON.stringify(h2)); });Comparing hashesYou can use the validate() method to compare two pass-phrases. The first argument is the entered password, and the second argument is the hashed password to be compared to. hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { const old = hashed.toString(hasher.encoding); hasher.validate(&quot;password&quot;, old, (valid) =&gt; { return valid; }); });The validate() method uses hasher.encoding by default, but this can be overridden by supplying the optional parameter at the end. hasher.validate(..., (valid) =&gt; { // Do something }, &quot;utf8&quot;);DocumentationA full documentation can be found here. × Search results Close "},"Decoded.html":{"id":"Decoded.html","title":"Class: Decoded","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Class: Decoded Decoded new Decoded(key, salt, iter) Stores hashed pass-phrase as decoded Strings. Parameters: Name Type Description key String The decoded key salt String The decoded salt iter Number The number of PBKDF2 iterations Source: lib/Decoded.js, line 12 Methods encode(enc) Encodes the Decoded object into an Encoded object. Parameters: Name Type Description enc String Encoding scheme to be used Source: lib/Decoded.js, line 26 See: Encoded Returns: The Encoded object Type Encoded getIteration() Source: lib/Decoded.js, line 85 Returns: Type Number getKey() Source: lib/Decoded.js, line 49 Returns: Type String getSalt() Source: lib/Decoded.js, line 67 Returns: Type Buffer setIteration(iter) Parameters: Name Type Description iter Number Source: lib/Decoded.js, line 94 setKey(key) Parameters: Name Type Description key Buffer Source: lib/Decoded.js, line 58 setSalt(salt) Parameters: Name Type Description salt Buffer Source: lib/Decoded.js, line 76 toString() The hash string has the format iter:salt:key. Source: lib/Decoded.js, line 40 Returns: The hash string Type String × Search results Close "},"Encoded.html":{"id":"Encoded.html","title":"Class: Encoded","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Class: Encoded Encoded new Encoded(key, salt, iter) Stores hashed pass-phrase as Buffers. Parameters: Name Type Description key Buffer The hashed key salt Buffer The hashed salt iter Number The Number of PBKDF2 iterations Source: lib/Encoded.js, line 13 Methods &lt;static&gt; parse(pass, enc) Parses a hash string into an Encoded object. Parameters: Name Type Description pass String The hash string enc String Encoding scheme to be used Source: lib/Encoded.js, line 27 Returns: The Encoded object Type Encoded decode(enc) Decodes the Encoded object into a Decoded object. Parameters: Name Type Description enc String Encoding scheme to be used Source: lib/Encoded.js, line 43 See: Decoded Returns: The Decoded object Type Decoded getIteration() Source: lib/Encoded.js, line 104 Returns: Type Number getKey() Source: lib/Encoded.js, line 68 Returns: Type Buffer getSalt() Source: lib/Encoded.js, line 86 Returns: Type Buffer setIteration(iter) Parameters: Name Type Description iter Number Source: lib/Encoded.js, line 113 setKey(key) Parameters: Name Type Description key Buffer Source: lib/Encoded.js, line 77 setSalt(salt) Parameters: Name Type Description salt Buffer Source: lib/Encoded.js, line 95 toString(enc) The hash string has the format iter:salt:key. Parameters: Name Type Description enc String Encoding scheme to be used Source: lib/Encoded.js, line 58 See: Decoded#toString × Search results Close "},"Hasher.html":{"id":"Hasher.html","title":"Class: Hasher","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Class: Hasher Hasher new Hasher() Creates and validates hashes. Source: lib/Hasher.js, line 19 Members &lt;inner&gt; saltByte :Number Length of the salt in bytes Type: Number Source: lib/Hasher.js, line 31 Methods generateSalt(callback [, urand]) Parameters: Name Type Argument Default Description callback Hasher~saltCallback Handles the randomly generated salt urand Boolean &lt;optional&gt; true Determines whether to use /dev/urandom or the time stamp as the random source Source: lib/Hasher.js, line 45 hash(pwd, callback [, urand]) Hashes the provided pass-phrase Parameters: Name Type Argument Default Description pwd String Password to hash callback Hasher~hashCallback Handles the hashed object urand Boolean &lt;optional&gt; true Determines whether to use /dev/urandom or the time stamp as the random source Source: lib/Hasher.js, line 68 validate(new_, old, callback [, enc]) Parameters: Name Type Argument Description new_ String Given pass-phrase old String The encoded hash string to compare to callback Hasher-validatorCallback Handles the validation result enc String &lt;optional&gt; The encoding scheme to be used (uses hasher.encoding as default) Source: lib/Hasher.js, line 101 Example // Create a hash hasher.hash(&quot;password&quot;, (err, hashed) =&gt; { const old = hashed.toString(hasher.encoding); // Generate hash string with default encoding scheme hasher.validate(&quot;password&quot;, old, (valid) =&gt; { assert.equal(valid, true); }); }); Type Definitions hashCallback(err, hashed) This callback takes the generated hash as an Encoded object. It also handles any errors from the PBKDF2 process. Parameters: Name Type Description err Object hashed Encoded The hashed object Source: lib/Hasher.js, line 77 See: Encoded saltCallback(salt) This callback takes the randomly generated salt and allows it to be handled appropriately. Parameters: Name Type Description salt Buffer Randomly generated salt Source: lib/Hasher.js, line 53 validatorCallback(valid) This callback handles the validation result. Parameters: Name Type Description valid Boolean Validation test result Source: lib/Hasher.js, line 110 × Search results Close "},"module-template_publish.html":{"id":"module-template_publish.html","title":"Module: template/publish","body":" DocStrap Modules template/publish Classes DecodedEncodedHasher Module: template/publish Source: template/publish.js, line 3 Methods &lt;static&gt; publish(taffyData, opts, tutorials) Parameters: Name Type Description taffyData TAFFY See . opts object tutorials Tutorial Source: template/publish.js, line 489 &lt;inner&gt; buildNav(members) Create the navigation sidebar. Parameters: Name Type Description members object The members that will be used to create the sidebar. Properties Name Type Description classes array.&lt;object&gt; externals array.&lt;object&gt; globals array.&lt;object&gt; mixins array.&lt;object&gt; interfaces array.&lt;object&gt; modules array.&lt;object&gt; namespaces array.&lt;object&gt; tutorials array.&lt;object&gt; events array.&lt;object&gt; Source: template/publish.js, line 361 Returns: The HTML for the navigation sidebar. Type string × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
